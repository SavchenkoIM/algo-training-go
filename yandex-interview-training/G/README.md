# G. Интересное путешествие

Не секрет, что некоторые программисты очень любят путешествовать. Хорошо всем известный программист Петя тоже очень любит путешествовать, посещать музеи и осматривать достопримечательности других городов.

Для перемещений между из города в город он предпочитает использовать машину. При этом он заправляется только на станциях в городах, но не на станциях по пути. Поэтому он очень аккуратно выбирает маршруты, чтобы машина не заглохла в дороге. А ещё Петя очень важный член команды, поэтому он не может себе позволить путешествовать слишком долго. Он решил написать программу, которая поможет ему с выбором очередного путешествия. Но так как сейчас у него слишком много других задач, он попросил вас помочь ему.

Расстояние между двумя городами считается как сумма модулей разности по каждой из координат. Дороги есть между всеми парами городов.

## Формат ввода

В первой строке входных данных записано количество городов n (2≤n≤1000). В следующих n строках даны два целых числа: координаты каждого города, не превосходящие по модулю миллиарда. Все города пронумерованы числами от 1 до n в порядке записи во входных данных.

В следующей строке записано целое положительное число k, не превосходящее двух миллиардов, — максимальное расстояние между городами, которое Петя может преодолеть без дозаправки машины.

В последней строке записаны два различных числа — номер города, откуда едет Петя, и номер города, куда он едет.

## Формат вывода

Если существуют пути, удовлетворяющие описанным выше условиям, то выведите минимальное количество дорог, которое нужно проехать, чтобы попасть из начальной точки маршрута в конечную. Если пути не существует, выведите -1.

## Пример 1
<table>
<tr><td><b>Ввод</b></td><td><b>Вывод</b></td></tr>
<tr><td>7<br>
0 0<br>
0 2<br>
2 2<br>
0 -2<br>
2 -2<br>
2 -1<br>
2 1<br>
2<br>
1 3
</td><td>2</td></tr>
</table>

## Пример 2
<table>
<tr><td><b>Ввод</b></td><td><b>Вывод</b></td></tr>
<tr><td>4<br>
0 0<br>
1 0<br>
0 1<br>
1 1<br>
2<br>
1 4
</td><td>1</td></tr>
</table>

## Пример 3
<table>
<tr><td><b>Ввод</b></td><td><b>Вывод</b></td></tr>
<tr><td>4<br>
0 0<br>
2 0<br>
0 2<br>
2 2<br>
1<br>
1 4
</td><td>-1</td></tr>
</table>

---
# Решение

Решаем итеративно. Начинаем с массива, состоящего из одного города, который является пунктом отправления. Затем на каждом шаге для этого массива составляем массив городов, в которые можно проехать без дозаправки из любого города исходного массива. При этом в этот массив не включаются города, которые мы уже добавляли ранее (хоть на этой итерации, хоть на более ранних). Таким образом число городов в этом массиве-"инварианте" не растёт экспоненциально. Переходим к следующей итерации уже относительно нового массива.

Если на каком-то шаге итерации мы добавили в массив город назначения, то возвращаем номер шага, на котором мы до него дошли, это и есть ответ. Если массив-"инвариант" на каком-то шаге получился пустым, то возвращаем "-1", то есть искомого пути не существует. Если пути не существует, то в какой-то момент мы обязательно получим пустой массив хотя бы потому, что в него не добавляются все города, которые уже были ранее добавлены.

Поиск городов, в которые можно попасть из заданного города, производится оптимизированно, чтобы исключить полный перебор "каждого города с каждым". Изначально создаётся две копии массива городов, одна из которых отсортирована по X, другая по Y. Все города, доступные для перехода, гарантированно находятся в квадрате {X-X_сосед, Y-Y_сосед}, {X+X_сосед, Y+Y_сосед}, все города из этого квадрата мы можем найти в отсортированных массивах за log(N). (В моей реализации можно кое что улучшить, но в итоге и так быстро работает). Затем перепроверяем каждый из найденных городов на возможность перехода.

Примечание. В решении активно используется тот факт, что граф - не взвешенный, то есть длина пути до города, полученного на шаге N всегда равна N, так как каждый переход стоит "1". Поэтому ранее добавленные города можно заново не посещать, так как маршруты до этого города, найденные на предыдущих шагах, гарантированно более короткие. Если бы граф был взвешенным, то условие "не посещать город повторно" следовало бы заменить на "не посещать город повторно, если ранее найденный путь до него более короткий, чем текущий". Почути вся нужная для этого доп информация уже (избыточно) имеется в текущем решении.
