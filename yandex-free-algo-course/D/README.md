# D. Matrix. Resurrection

Вам дана матрица из n строк и m столбцов, заполненная натуральными числами. По матрице можно перемещаться, из клетки можно уходить только в соседнюю по стороне клетку, переходы по диагонали, а также выход за границу матрицы запрещены.

Ваша задача — найти наиболее длинный возрастающий путь в матрице. Путь возрастающий, если значения в посещаемых клетках строго возрастают от начала пути к его концу.

## Формат ввода

В первой строке даны два числа, описывающие размер матрицы — n, m (1≤n,m≤10<sup>3</sup>). В следующих n строках записана сама матрица. i-я строка матрицы содержит m чисел, записанных через пробел. Все элементы матрицы — натуральные числа, не превосходящие 10<sup>9</sup>.

## Формат вывода

Выведите единственное число — длину наибольшего возрастающего пути.

## Пример 1
<table>
<tr><td><b>Ввод</b></td><td><b>Вывод</b></td></tr>
<tr><td>2 3<br>
10 8 5<br>
10 5 4
</td><td>4</td></tr>
</table>

## Пример 2
<table>
<tr><td><b>Ввод</b></td><td><b>Вывод</b></td></tr>
<tr><td>2 2<br>
1 1<br>
1 1
</td><td>1</td></tr>
</table>

## Пример 3
<table>
<tr><td><b>Ввод</b></td><td><b>Вывод</b></td></tr>
<tr><td>2 2<br>
10 9<br>
9 11
</td><td>2</td></tr>
</table>


---
# Решение

Для удобства сперва построим дерево, где у каждого узла есть "вес", "максимальная длина возрастающего пути" (изначально берётся равной 0, то есть "неизвестно") и массив ссылок на все узлы, куда из него можно перейти (чтобы при этом не выйти за границу матрицы и вес следующего узла был строго больше). Эта процедура выполняется за O(N).

Далее по этому дереву считаем длину искомого пути из каждого узла. Функция поиска максимальной длины пути из узла реализована в виде рекурсии с кэшированием уже посчитанных на предыдущих шагах результатов, за счёт чего асимптотика получается приемлемой. Функция короткая, проще посмотреть реализацию чем описывать.

Длина самого длинного из найденных путей будет ответом.
