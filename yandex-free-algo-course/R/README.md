# R. Паша и Марк

Паша и Марк играют в игру. Изначально есть число n. Текущий игрок может выбрать любой делитель d числа n, который удовлетворяет условию d<n. Далее этот игрок заменяет n на n−d. Проигрывает тот, кто не может сделать ход. Определите, кто выиграет при оптимальной игре. Первый ход всегда делает Паша.

## Формат ввода

На вход подаётся единственное число n (1≤n≤10000)

## Формат вывода

Выведите «Pasha», если выиграет Паша, или «Mark», если победа за Марком.

## Пример 1
<table>
<tr><td><b>Ввод</b></td><td><b>Вывод</b></td></tr>
<tr><td>8</td><td>Pasha</td></tr>
</table>

## Пример 2
<table>
<tr><td><b>Ввод</b></td><td><b>Вывод</b></td></tr>
<tr><td>3</td><td>Mark</td></tr>
</table>

---

# Решение

Для начала немного проясним один неочевидный момент в условии задачи: 1 тоже является делителем. То есть проигрывает тот, кто получает в свой ход число 1 (все остальные числа можно как минимум уменьшить на 1 в свой ход).

Решим, использовав такую хитрую структуру данных, как проиндексированное дерево. Создадим дерево из связанных между собой узлов, где каждый узел представляет число от 1 до 10000 (10000 - по условию максимально возможное начальное число в игре). Каждый узел имеет `Value` - то число, которое он представляет, `next` - слайс указателей на те узлы, на которые можно перейти за 1 ход, и `type` - признак того, является ли `Value` этого узла "победным" для Паши, или, наоборот, при таком начальном значении выиграет Марк. Изначально `Type` "пустой" - нет информации о "победности" `Value` узла.

Также существует мапа, которая по `Value` возвращает указатель на узел с этим `Value`. Как всё это строится, проще посмотреть по коду.

Далее итеративно начиная с узла 1 идём до узла 10000 и определяем `Type` каждого текущего узла, то есть победит ли Паша, если игра стартует с соответствующего числа.

Алгоритм определения "типа" узла:

* Очевидно, что если у узла `next` пустой, то это "поражение", или "Mark", так как из него Паша не сможет сделать свой первый же ход.
* Также "поражение", если не существует такого узла, в который можно было бы перейти за 1 ход из данного узла, и который бы имел тип "поражение". Это тоже достаточно очевидно, в таком случае Паша делает ход, и у Марка оказывается узел с типом "победа", то есть победит Марк.
* Тип "победа", если существует хотя бы один узел с типом "поражение", в которой можно перейти за 1 ход из текущего узла. Именно в него Паша и перейдёт, а Марк проиграет.

Примечание. Так как из любого узла мы можем перейти только в узел с меньшим `Value`, то при итерировании от меньших узлов к большим мы всегда будем точно знать "тип" всех узлов, в которые можно перейти из текущего.

После этих операций у нас есть информация о каждом числе от 1 до 10000 - победит ли Паша, если игра начнётся с этого числа (можем извлечь эти данные из индексирующей мапы за O(1)).
