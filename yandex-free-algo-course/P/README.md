# P. Граница дерева

Дано укоренённое бинарное дерево на N вершинах. Скажем, что вершина v находится на границе дерева, если она подходит под любое из условий:

* v является листом;
* пусть v находится на расстоянии h от корня. Тогда v — самая левая или самая правая вершина среди всех вершин на расстоянии h от корня.

Найдите все вершины, находящиеся на границе дерева.

## Формат ввода

В первой строке записаны два целых числа: количество вершин в дереве n(1≤n≤2⋅10<sup>5</sup>) и root<sub>id</sub>(0≤root<sub>id</sub>≤n−1) — номер вершины-корня.

В следующих n строках описаны вершины. Каждая вершина описывается двумя числами, записанными через пробел: id левого потомка и id правого потомка. Все id находятся в диапазоне [0;n−1]. Если у вершины нет какого-то потомка, то вместо его id будет −1. Гарантируется, что входные данные корректны.

## Формат вывода

В единственной строке через пробел выведите в любом порядке все id вершин, которые находятся на границе дерева. Каждая вершина должна быть выведена не более одного раза.

## Пример 1
<table>
<tr><td><b>Ввод</b></td><td><b>Вывод</b></td></tr>
<tr><td>10 0<br>
1 2<br>
3 4<br>
5 6<br>
7 -1<br>
8 -1<br>
-1 -1<br>
9 -1<br>
-1 -1<br>
-1 -1<br>
-1 -1
</td><td>5 8 9 1 0 7 3 2 6</td></tr>
</table>

---
# Решение

Здесь как-то очень красиво решить, кажется, не получается, поэтому решим просто эффективно.

Решение будет итеративным. На каждой итерации будем обрабатывать один уровень дерева (начиная с корня), и распечатывать в `stdout` нужные узлы из него. Также на каждой итерации подготавливается массив со следующим уровнем дерева для следующей итерации.

Печатаем id узла, если он: первый или последний в массиве узлов данного уровня, либо является листом (оба чайлда равны -1).

Следующий уровень генерируем из текущего таким образом. Последовательно проходим по всем узлам текущего уровня, и для каждого из них вставляем в массив следующего уровня сначала левого потомка (если он не -1), затем правого потомка (если он не -1). При таком подходе на каждом уровне "граничные" узлы будут вначале и в конце массива.

Итерация прекращается когда массив следующего уровня окажется пустым.
