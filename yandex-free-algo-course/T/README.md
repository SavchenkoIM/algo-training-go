# T. XORошая задача

В этой задаче требуется по заданному массиву длины n найти два его элемента xi и xj(1≤i≤j≤n), которые давали бы максимальное значение функции x<sub>i</sub>⊕x<sub>j</sub>, где под ⊕ подразумевается операция побитового исключающего «или», то есть xor.


## Формат ввода

В первой строке дан размер массива n (1≤n≤10<sup>5</sup>).

Во второй строке через пробел записаны n целых чисел x<sub>i</sub> (1≤xi≤2<sup>31</sup>−1).

## Формат вывода

Выведите единственное число — максимальное значение xor-а, которое можно получить.

## Пример 1
<table>
<tr><td><b>Ввод</b></td><td><b>Вывод</b></td></tr>
<tr><td>5<br>
1 8 3 1 4
</td><td>12</td></tr>
</table>

## Пример 2
<table>
<tr><td><b>Ввод</b></td><td><b>Вывод</b></td></tr>
<tr><td>3<br>
4 8 1024
</td><td>1032</td></tr>
</table>

## Пример 3
<table>
<tr><td><b>Ввод</b></td><td><b>Вывод</b></td></tr>
<tr><td>2<br>
10 10
</td><td>0</td></tr>
</table>

---
# Решение

Нам нужно найти такие два числа, чтобы у них в максимально возможном количестве двоичных разрядов были противоположные значения, причём старшие разряды имеют наибольший приоритет.

Для этого для начала отсортируем все числа по возрастанию, и найдём такие числа, у которых в самом старшем среди всех числе разряде единица. Этот набор чисел возьмём в качестве "якоря".

Далее для каждого числа из слайса "якоря" находим наибольшее значение xor с любым другим числом из testcase'a, оптимизируя поиск руководствуюясь первым абзацем данного раздела:

Итеративно поразрядно (двоичные разряды) проходим по числу из "якоря" начиная со старшего разряда до тех пор, пока не дойдём до нулевого разряда. На каждой итерации ищем числа, которые потенциально дадут наибольший xor, то есть в этом i-том разряде у них будет другое значение.

Если существуют числа, у которых в этом разряде противоположное значение, отсекаем из testcase'a те, у которых значение одинаковое, и инкрементируем аккумулятор на 2<sup>номер_разряда</sup> (нашлась пара, у которой в этом разраде xor даёт 1). Если таких чисел не нашлось, просто переходим на следующий разряд.

В результате прохождения всех итераций по всем элементам "якоря", мы получаем массив чисел, максимальное из которых будет решением задачи.
