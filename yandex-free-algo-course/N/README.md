# N. Атака клонов

В этой задаче требуется создать копию связного графа. Оригинальный граф задается одной вершиной. Вершина содержит свое уникальное значение – `value`, и список соседей `neighbours`. Граф будет считаться копией, если в графе-копии есть связь между вершинами со значениями v<sub>1</sub> и v<sub>2</sub> тогда и только тогда, когда она есть в оригинальном графе. Все вершины графа-копии должны быть созданы заново, то есть нельзя переиспользовать вершины из оригинального графа. Создавайте новые вершины с помощью публичных конструкторов и фабричных методов, указанных в шаблонах.

## Формат ввода

Функция `cloneGraph` принимает стартовую вершину, которая принадлежит оригинальному графу.

## Формат вывода

Функция `cloneGraph` должна возвращать вершину, являющуюся копией стартовой вершины в оригинальном графе.

---
# Решение

Здесь применяется паттерн рекурсивного клонирования (для всех "детей" вызывается такой же метод "клонировать_узел", как и для родительского, затем все склонированные узлы добавляются к склонированному родителю), с той поправкой, что это не дерево, а граф, а значит здесь могут быть замкнутые петли.

Для разрешения таких петель применим мапу, в которой задаётся соответстуие "указатель_на_узел"->"указатель_на_узел". Если мы склонировали узел, то заносим в мапу ключ: указатель на оригинальный узел, значение: указатель на клонированный узел. Если на каком-то рекурсивном шаге требуется склонировать узел, который уже был склонирован, вместо повторного клонирвания, из мапы извлекается и возвращается указатель на уже существующий склонированный узел.
